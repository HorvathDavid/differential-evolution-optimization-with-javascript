/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n\n//  Test functions\n// https://en.wikipedia.org/wiki/Test_functions_for_optimization\n\n// sphere func\nfunction func1(x) {\n    return x.reduce((prev, current) => {\n        return prev + Math.pow(current, 2);\n    }, 0)\n}\n\n// Himmelblau's function\nfunction func2(x) {\n    const e = Math.pow(Math.pow(x[0], 2) + x[1]-11, 2) + Math.pow(x[0] + Math.pow(x[1], 2) -7, 2)\n    return e\n}\n\n// func1(_.range(12)).then(a => console.log(a)).catch();\n\n\nfunction ensure_bounds(vec, bounds) {\n    const vec_new = []\n    for (let i of !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(vec.length)) {\n        // console.log(vec)\n        // console.log(bounds)\n\n        if (vec[i] < bounds[i][0]) {\n            vec_new.push(bounds[i][0])\n        }\n    \n        if (vec[i] > bounds[i][1]) {\n            vec_new.push(bounds[i][1])\n        }\n    \n        if (bounds[i][0] <= vec[i] <= bounds[i][1]) {\n            vec_new.push(vec[i])\n        }\n    }\n \n    return vec_new\n}\n\nfunction main(cost_func, bounds, popsize, mutate, recombination, maxiter) {\n\n    //--- INITIALIZE A POPULATION (step #1) ----------------+\n    \n    const population = []\n    for (let i in !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(popsize)) {\n        let indv = []\n        for (let j in !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(bounds.length)) {\n            // indv.push(_.random(bounds[j][0],bounds[j][1]))\n            // indv.push(_.random(bounds[j][0],bounds[j][1], true))\n            indv.push(bounds[j][0] + Math.random()*(bounds[j][1] - bounds[j][0]))\n        }\n        population.push(indv)\n    }\n\n    console.log('first pop', population)\n            \n    //--- SOLVE --------------------------------------------+\n    \n    // cycle through each generation (step #2)\n    for (let i in !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(maxiter+1)) {\n        console.log('GENERATION:', i)\n    \n        var gen_scores = [] // score keeping\n    \n        // cycle through each individual in the population\n        for (let j in !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(popsize)) {\n            //--- MUTATION (step #3.A) ---------------------+\n            \n            // select three random vector index positions [0, popsize), not including current vector (j)\n            let canidates = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(popsize)\n            canidates.splice(j, 1)\n            let random_index = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).sampleSize(canidates, 3)\n    \n            let x_1 = population[random_index[0]]\n            let x_2 = population[random_index[1]]\n            let x_3 = population[random_index[2]]\n            let x_t = population[j]     // target individual\n    \n            // subtract x3 from x2, and create a new vector (x_diff)\n            let x_diff = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).zip(x_3, x_2).map(e => e[0] - e[1])\n    \n            // multiply x_diff by the mutation factor (F) and add to x_1\n            let v_donor = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).zip(x_1, x_diff).map(e => e[0] + mutate * e[1])\n            v_donor = ensure_bounds(v_donor, bounds)\n    \n            //--- RECOMBINATION (step #3.B) ----------------+\n    \n            let v_trial = []\n            for (let k in !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).range(x_t.length)) {\n                let crossover = Math.random()\n                if (crossover <= recombination) {\n                    v_trial.push(v_donor[k])\n                    \n                } else {\n                    v_trial.push(x_t[k])\n                }\n            }\n                    \n            //--- GREEDY SELECTION (step #3.C) -------------+\n    \n            let score_trial  = cost_func(v_trial)\n            let score_target = cost_func(x_t)\n    \n            if (score_trial < score_target) {\n                population[j] = v_trial\n                gen_scores.push(score_trial)\n                console.log('   >',score_trial, v_trial)\n            } else {\n                console.log( '   >',score_target, x_t)\n                gen_scores.push(score_target)\n            }\n        }\n    \n    \n    }\n    //--- SCORE KEEPING --------------------------------+\n\n    let gen_avg = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).sum(gen_scores) / popsize                         // current generation avg. fitness\n    let gen_best = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"lodash\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).min(gen_scores)                                  // fitness of best individual\n    let gen_sol = population[gen_scores.indexOf(gen_best)]     // solution of best individual\n\n    console.log( ' > GENERATION AVERAGE:',gen_avg)\n    console.log( ' > GENERATION BEST:',gen_best)\n    console.log( ' > BEST SOLUTION:',gen_sol)\n    \n    return gen_sol\n}\n\n\n//--- CONSTANTS ----------------------------------------------------------------+\n\nconst cost_func = func2                   // Cost function\nconst bounds = [[-5,5],[-5,5]]            // Bounds [(x1_min, x1_max), (x2_min, x2_max),...]\nconst popsize = 20                        // Population size, must be >= 4\nconst mutate = 0.5                        // Mutation factor [0,2]\nconst recombination = 0.7                 // Recombination rate [0,1]\nconst maxiter = 40                        // Max number of generations (maxiter)\n\n//--- RUN ----------------------------------------------------------------------+\n\nmain(cost_func, bounds, popsize, mutate, recombination, maxiter)\n\n//--- END ----------------------------------------------------------------------+\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzQxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJ1xuXG4vLyAgVGVzdCBmdW5jdGlvbnNcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Rlc3RfZnVuY3Rpb25zX2Zvcl9vcHRpbWl6YXRpb25cblxuLy8gc3BoZXJlIGZ1bmNcbmZ1bmN0aW9uIGZ1bmMxKHgpIHtcbiAgICByZXR1cm4geC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXYgKyBNYXRoLnBvdyhjdXJyZW50LCAyKTtcbiAgICB9LCAwKVxufVxuXG4vLyBIaW1tZWxibGF1J3MgZnVuY3Rpb25cbmZ1bmN0aW9uIGZ1bmMyKHgpIHtcbiAgICBjb25zdCBlID0gTWF0aC5wb3coTWF0aC5wb3coeFswXSwgMikgKyB4WzFdLTExLCAyKSArIE1hdGgucG93KHhbMF0gKyBNYXRoLnBvdyh4WzFdLCAyKSAtNywgMilcbiAgICByZXR1cm4gZVxufVxuXG4vLyBmdW5jMShfLnJhbmdlKDEyKSkudGhlbihhID0+IGNvbnNvbGUubG9nKGEpKS5jYXRjaCgpO1xuXG5cbmZ1bmN0aW9uIGVuc3VyZV9ib3VuZHModmVjLCBib3VuZHMpIHtcbiAgICBjb25zdCB2ZWNfbmV3ID0gW11cbiAgICBmb3IgKGxldCBpIG9mIF8ucmFuZ2UodmVjLmxlbmd0aCkpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2codmVjKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhib3VuZHMpXG5cbiAgICAgICAgaWYgKHZlY1tpXSA8IGJvdW5kc1tpXVswXSkge1xuICAgICAgICAgICAgdmVjX25ldy5wdXNoKGJvdW5kc1tpXVswXSlcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAodmVjW2ldID4gYm91bmRzW2ldWzFdKSB7XG4gICAgICAgICAgICB2ZWNfbmV3LnB1c2goYm91bmRzW2ldWzFdKVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChib3VuZHNbaV1bMF0gPD0gdmVjW2ldIDw9IGJvdW5kc1tpXVsxXSkge1xuICAgICAgICAgICAgdmVjX25ldy5wdXNoKHZlY1tpXSlcbiAgICAgICAgfVxuICAgIH1cbiBcbiAgICByZXR1cm4gdmVjX25ld1xufVxuXG5mdW5jdGlvbiBtYWluKGNvc3RfZnVuYywgYm91bmRzLCBwb3BzaXplLCBtdXRhdGUsIHJlY29tYmluYXRpb24sIG1heGl0ZXIpIHtcblxuICAgIC8vLS0tIElOSVRJQUxJWkUgQSBQT1BVTEFUSU9OIChzdGVwICMxKSAtLS0tLS0tLS0tLS0tLS0tK1xuICAgIFxuICAgIGNvbnN0IHBvcHVsYXRpb24gPSBbXVxuICAgIGZvciAobGV0IGkgaW4gXy5yYW5nZShwb3BzaXplKSkge1xuICAgICAgICBsZXQgaW5kdiA9IFtdXG4gICAgICAgIGZvciAobGV0IGogaW4gXy5yYW5nZShib3VuZHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgLy8gaW5kdi5wdXNoKF8ucmFuZG9tKGJvdW5kc1tqXVswXSxib3VuZHNbal1bMV0pKVxuICAgICAgICAgICAgLy8gaW5kdi5wdXNoKF8ucmFuZG9tKGJvdW5kc1tqXVswXSxib3VuZHNbal1bMV0sIHRydWUpKVxuICAgICAgICAgICAgaW5kdi5wdXNoKGJvdW5kc1tqXVswXSArIE1hdGgucmFuZG9tKCkqKGJvdW5kc1tqXVsxXSAtIGJvdW5kc1tqXVswXSkpXG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGlvbi5wdXNoKGluZHYpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ2ZpcnN0IHBvcCcsIHBvcHVsYXRpb24pXG4gICAgICAgICAgICBcbiAgICAvLy0tLSBTT0xWRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICBcbiAgICAvLyBjeWNsZSB0aHJvdWdoIGVhY2ggZ2VuZXJhdGlvbiAoc3RlcCAjMilcbiAgICBmb3IgKGxldCBpIGluIF8ucmFuZ2UobWF4aXRlcisxKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnR0VORVJBVElPTjonLCBpKVxuICAgIFxuICAgICAgICB2YXIgZ2VuX3Njb3JlcyA9IFtdIC8vIHNjb3JlIGtlZXBpbmdcbiAgICBcbiAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCBlYWNoIGluZGl2aWR1YWwgaW4gdGhlIHBvcHVsYXRpb25cbiAgICAgICAgZm9yIChsZXQgaiBpbiBfLnJhbmdlKHBvcHNpemUpKSB7XG4gICAgICAgICAgICAvLy0tLSBNVVRBVElPTiAoc3RlcCAjMy5BKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNlbGVjdCB0aHJlZSByYW5kb20gdmVjdG9yIGluZGV4IHBvc2l0aW9ucyBbMCwgcG9wc2l6ZSksIG5vdCBpbmNsdWRpbmcgY3VycmVudCB2ZWN0b3IgKGopXG4gICAgICAgICAgICBsZXQgY2FuaWRhdGVzID0gXy5yYW5nZShwb3BzaXplKVxuICAgICAgICAgICAgY2FuaWRhdGVzLnNwbGljZShqLCAxKVxuICAgICAgICAgICAgbGV0IHJhbmRvbV9pbmRleCA9IF8uc2FtcGxlU2l6ZShjYW5pZGF0ZXMsIDMpXG4gICAgXG4gICAgICAgICAgICBsZXQgeF8xID0gcG9wdWxhdGlvbltyYW5kb21faW5kZXhbMF1dXG4gICAgICAgICAgICBsZXQgeF8yID0gcG9wdWxhdGlvbltyYW5kb21faW5kZXhbMV1dXG4gICAgICAgICAgICBsZXQgeF8zID0gcG9wdWxhdGlvbltyYW5kb21faW5kZXhbMl1dXG4gICAgICAgICAgICBsZXQgeF90ID0gcG9wdWxhdGlvbltqXSAgICAgLy8gdGFyZ2V0IGluZGl2aWR1YWxcbiAgICBcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IHgzIGZyb20geDIsIGFuZCBjcmVhdGUgYSBuZXcgdmVjdG9yICh4X2RpZmYpXG4gICAgICAgICAgICBsZXQgeF9kaWZmID0gXy56aXAoeF8zLCB4XzIpLm1hcChlID0+IGVbMF0gLSBlWzFdKVxuICAgIFxuICAgICAgICAgICAgLy8gbXVsdGlwbHkgeF9kaWZmIGJ5IHRoZSBtdXRhdGlvbiBmYWN0b3IgKEYpIGFuZCBhZGQgdG8geF8xXG4gICAgICAgICAgICBsZXQgdl9kb25vciA9IF8uemlwKHhfMSwgeF9kaWZmKS5tYXAoZSA9PiBlWzBdICsgbXV0YXRlICogZVsxXSlcbiAgICAgICAgICAgIHZfZG9ub3IgPSBlbnN1cmVfYm91bmRzKHZfZG9ub3IsIGJvdW5kcylcbiAgICBcbiAgICAgICAgICAgIC8vLS0tIFJFQ09NQklOQVRJT04gKHN0ZXAgIzMuQikgLS0tLS0tLS0tLS0tLS0tLStcbiAgICBcbiAgICAgICAgICAgIGxldCB2X3RyaWFsID0gW11cbiAgICAgICAgICAgIGZvciAobGV0IGsgaW4gXy5yYW5nZSh4X3QubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGxldCBjcm9zc292ZXIgPSBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICAgICAgaWYgKGNyb3Nzb3ZlciA8PSByZWNvbWJpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZfdHJpYWwucHVzaCh2X2Rvbm9yW2tdKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2X3RyaWFsLnB1c2goeF90W2tdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLy0tLSBHUkVFRFkgU0VMRUNUSU9OIChzdGVwICMzLkMpIC0tLS0tLS0tLS0tLS0rXG4gICAgXG4gICAgICAgICAgICBsZXQgc2NvcmVfdHJpYWwgID0gY29zdF9mdW5jKHZfdHJpYWwpXG4gICAgICAgICAgICBsZXQgc2NvcmVfdGFyZ2V0ID0gY29zdF9mdW5jKHhfdClcbiAgICBcbiAgICAgICAgICAgIGlmIChzY29yZV90cmlhbCA8IHNjb3JlX3RhcmdldCkge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRpb25bal0gPSB2X3RyaWFsXG4gICAgICAgICAgICAgICAgZ2VuX3Njb3Jlcy5wdXNoKHNjb3JlX3RyaWFsKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcgICA+JyxzY29yZV90cmlhbCwgdl90cmlhbClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coICcgICA+JyxzY29yZV90YXJnZXQsIHhfdClcbiAgICAgICAgICAgICAgICBnZW5fc2NvcmVzLnB1c2goc2NvcmVfdGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgfVxuICAgIC8vLS0tIFNDT1JFIEtFRVBJTkcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5cbiAgICBsZXQgZ2VuX2F2ZyA9IF8uc3VtKGdlbl9zY29yZXMpIC8gcG9wc2l6ZSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGdlbmVyYXRpb24gYXZnLiBmaXRuZXNzXG4gICAgbGV0IGdlbl9iZXN0ID0gXy5taW4oZ2VuX3Njb3JlcykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml0bmVzcyBvZiBiZXN0IGluZGl2aWR1YWxcbiAgICBsZXQgZ2VuX3NvbCA9IHBvcHVsYXRpb25bZ2VuX3Njb3Jlcy5pbmRleE9mKGdlbl9iZXN0KV0gICAgIC8vIHNvbHV0aW9uIG9mIGJlc3QgaW5kaXZpZHVhbFxuXG4gICAgY29uc29sZS5sb2coICcgPiBHRU5FUkFUSU9OIEFWRVJBR0U6JyxnZW5fYXZnKVxuICAgIGNvbnNvbGUubG9nKCAnID4gR0VORVJBVElPTiBCRVNUOicsZ2VuX2Jlc3QpXG4gICAgY29uc29sZS5sb2coICcgPiBCRVNUIFNPTFVUSU9OOicsZ2VuX3NvbClcbiAgICBcbiAgICByZXR1cm4gZ2VuX3NvbFxufVxuXG5cbi8vLS0tIENPTlNUQU5UUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuXG5jb25zdCBjb3N0X2Z1bmMgPSBmdW5jMiAgICAgICAgICAgICAgICAgICAvLyBDb3N0IGZ1bmN0aW9uXG5jb25zdCBib3VuZHMgPSBbWy01LDVdLFstNSw1XV0gICAgICAgICAgICAvLyBCb3VuZHMgWyh4MV9taW4sIHgxX21heCksICh4Ml9taW4sIHgyX21heCksLi4uXVxuY29uc3QgcG9wc2l6ZSA9IDIwICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGlvbiBzaXplLCBtdXN0IGJlID49IDRcbmNvbnN0IG11dGF0ZSA9IDAuNSAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11dGF0aW9uIGZhY3RvciBbMCwyXVxuY29uc3QgcmVjb21iaW5hdGlvbiA9IDAuNyAgICAgICAgICAgICAgICAgLy8gUmVjb21iaW5hdGlvbiByYXRlIFswLDFdXG5jb25zdCBtYXhpdGVyID0gNDAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXggbnVtYmVyIG9mIGdlbmVyYXRpb25zIChtYXhpdGVyKVxuXG4vLy0tLSBSVU4gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcblxubWFpbihjb3N0X2Z1bmMsIGJvdW5kcywgcG9wc2l6ZSwgbXV0YXRlLCByZWNvbWJpbmF0aW9uLCBtYXhpdGVyKVxuXG4vLy0tLSBFTkQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ })

/******/ });